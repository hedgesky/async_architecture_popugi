## Попуги

Система, созданная в результате прохождения курса "Асинхронные системы". Состоит из 4х компонентов, взаимодействующих друг с другом в основном через RabbitMQ.

Логика компонентов (Auth, Tasks, Accounting, Analytics) намеренно странная — в полном соответствии с требованиями, поставленными в домашнем задании. Это было интересно.

Использовал data streaming, event storming; сделал диаграмму сущностей и коммуникации между сервисами (ссылки ниже). В качестве аутентификации — oauth2 с помощью Doorkeeper.

- [Event storming](events.md)
- [Диаграмма сущностей](entities.png)
- [Диаграмма сервисов](services.png)

![](popug.jpg)

## Установка системы

- PostgreSQL для компонентов запускается через docker compose. При первом запуске нужно прокидывать переменную окружения `POSTGRES_PASSWORD`, что постгрес правильно настроился. Этот же пароль потом нужно хранить в .env файлах (в случае аналитики) или прокидывать через .zconfig (в случае других компонентов)
- rabbitmq нужен для коммуникации компонентов между друг другом и тоже запускается через docker-compose из соответствующей папочки.
- Все компоненты системы — Rails сервисы, и там всё как обычно: `bundle install`, `webpacker`, `db:setup`, и прочее.

## Работа с системой

- Периодически начинают теряться сообщения в очередях. Как я понимаю, они приходят в очередь, но при интенсивной разработке системы где-то возникают ghost consumers, которые читают события и тем самым удаляют их из очереди, но при этом не вызывают необходимых side эффектов. В таких случаях помогает оставить все сервисы и отключить spring.
Ну и ещё полезная команда `rabbitmqctl list_consumers`, которую надо вызывать через `dc exec rabbitmq /bin/bash`.
- Аутентификация намеренно происходит синхронно на каждый запрос к системе. Интересно было исследовать такой подход, чтобы можно было выйти разом единомоментно из всех компонентов системы.
